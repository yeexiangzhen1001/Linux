// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mapgoo.paas.cap.socol.proto

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SocolTaskCache struct {
	Imei                 string              `protobuf:"bytes,1,opt,name=imei,proto3" json:"imei,omitempty"`
	CmdSeq               *SocolCmdSeq        `protobuf:"bytes,2,opt,name=cmd_seq,json=cmdSeq,proto3" json:"cmd_seq,omitempty"`
	CmdStatus            *SocolCmdStatus     `protobuf:"bytes,3,opt,name=cmd_status,json=cmdStatus,proto3" json:"cmd_status,omitempty"`
	TaskStatus           uint32              `protobuf:"varint,4,opt,name=task_status,json=taskStatus,proto3" json:"task_status,omitempty"`
	ExpiredTime          uint32              `protobuf:"varint,5,opt,name=expired_time,json=expiredTime,proto3" json:"expired_time,omitempty"`
	UploadMsg            *SocolUploadMessage `protobuf:"bytes,6,opt,name=upload_msg,json=uploadMsg,proto3" json:"upload_msg,omitempty"`
	UploadSummary        *SocolUploadSummary `protobuf:"bytes,7,opt,name=upload_summary,json=uploadSummary,proto3" json:"upload_summary,omitempty"`
	VersionCode          string              `protobuf:"bytes,8,opt,name=version_code,json=versionCode,proto3" json:"version_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SocolTaskCache) Reset()         { *m = SocolTaskCache{} }
func (m *SocolTaskCache) String() string { return proto.CompactTextString(m) }
func (*SocolTaskCache) ProtoMessage()    {}
func (*SocolTaskCache) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{0}
}
func (m *SocolTaskCache) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SocolTaskCache) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SocolTaskCache.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SocolTaskCache) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocolTaskCache.Merge(m, src)
}
func (m *SocolTaskCache) XXX_Size() int {
	return m.Size()
}
func (m *SocolTaskCache) XXX_DiscardUnknown() {
	xxx_messageInfo_SocolTaskCache.DiscardUnknown(m)
}

var xxx_messageInfo_SocolTaskCache proto.InternalMessageInfo

func (m *SocolTaskCache) GetImei() string {
	if m != nil {
		return m.Imei
	}
	return ""
}

func (m *SocolTaskCache) GetCmdSeq() *SocolCmdSeq {
	if m != nil {
		return m.CmdSeq
	}
	return nil
}

func (m *SocolTaskCache) GetCmdStatus() *SocolCmdStatus {
	if m != nil {
		return m.CmdStatus
	}
	return nil
}

func (m *SocolTaskCache) GetTaskStatus() uint32 {
	if m != nil {
		return m.TaskStatus
	}
	return 0
}

func (m *SocolTaskCache) GetExpiredTime() uint32 {
	if m != nil {
		return m.ExpiredTime
	}
	return 0
}

func (m *SocolTaskCache) GetUploadMsg() *SocolUploadMessage {
	if m != nil {
		return m.UploadMsg
	}
	return nil
}

func (m *SocolTaskCache) GetUploadSummary() *SocolUploadSummary {
	if m != nil {
		return m.UploadSummary
	}
	return nil
}

func (m *SocolTaskCache) GetVersionCode() string {
	if m != nil {
		return m.VersionCode
	}
	return ""
}

type SetSocolTaskCacheReq struct {
	TaskCache            *SocolTaskCache     `protobuf:"bytes,1,opt,name=task_cache,json=taskCache,proto3" json:"task_cache,omitempty"`
	ImageList            []*SocolUploadImage `protobuf:"bytes,3,rep,name=image_list,json=imageList,proto3" json:"image_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SetSocolTaskCacheReq) Reset()         { *m = SetSocolTaskCacheReq{} }
func (m *SetSocolTaskCacheReq) String() string { return proto.CompactTextString(m) }
func (*SetSocolTaskCacheReq) ProtoMessage()    {}
func (*SetSocolTaskCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{1}
}
func (m *SetSocolTaskCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSocolTaskCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSocolTaskCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSocolTaskCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSocolTaskCacheReq.Merge(m, src)
}
func (m *SetSocolTaskCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *SetSocolTaskCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSocolTaskCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetSocolTaskCacheReq proto.InternalMessageInfo

func (m *SetSocolTaskCacheReq) GetTaskCache() *SocolTaskCache {
	if m != nil {
		return m.TaskCache
	}
	return nil
}

func (m *SetSocolTaskCacheReq) GetImageList() []*SocolUploadImage {
	if m != nil {
		return m.ImageList
	}
	return nil
}

type SetSocolTaskCacheResp struct {
	Base                 *BaseRespInfo `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SetSocolTaskCacheResp) Reset()         { *m = SetSocolTaskCacheResp{} }
func (m *SetSocolTaskCacheResp) String() string { return proto.CompactTextString(m) }
func (*SetSocolTaskCacheResp) ProtoMessage()    {}
func (*SetSocolTaskCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{2}
}
func (m *SetSocolTaskCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSocolTaskCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSocolTaskCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSocolTaskCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSocolTaskCacheResp.Merge(m, src)
}
func (m *SetSocolTaskCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *SetSocolTaskCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSocolTaskCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_SetSocolTaskCacheResp proto.InternalMessageInfo

func (m *SetSocolTaskCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

type GetSocolTaskCacheReq struct {
	CmdSeq               *SocolCmdSeq `protobuf:"bytes,1,opt,name=cmd_seq,json=cmdSeq,proto3" json:"cmd_seq,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetSocolTaskCacheReq) Reset()         { *m = GetSocolTaskCacheReq{} }
func (m *GetSocolTaskCacheReq) String() string { return proto.CompactTextString(m) }
func (*GetSocolTaskCacheReq) ProtoMessage()    {}
func (*GetSocolTaskCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{3}
}
func (m *GetSocolTaskCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolTaskCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolTaskCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolTaskCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolTaskCacheReq.Merge(m, src)
}
func (m *GetSocolTaskCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolTaskCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolTaskCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolTaskCacheReq proto.InternalMessageInfo

func (m *GetSocolTaskCacheReq) GetCmdSeq() *SocolCmdSeq {
	if m != nil {
		return m.CmdSeq
	}
	return nil
}

type GetSocolTaskCacheResp struct {
	Base                 *BaseRespInfo       `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	TaskCache            *SocolTaskCache     `protobuf:"bytes,2,opt,name=task_cache,json=taskCache,proto3" json:"task_cache,omitempty"`
	ImageList            []*SocolUploadImage `protobuf:"bytes,3,rep,name=image_list,json=imageList,proto3" json:"image_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetSocolTaskCacheResp) Reset()         { *m = GetSocolTaskCacheResp{} }
func (m *GetSocolTaskCacheResp) String() string { return proto.CompactTextString(m) }
func (*GetSocolTaskCacheResp) ProtoMessage()    {}
func (*GetSocolTaskCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{4}
}
func (m *GetSocolTaskCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolTaskCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolTaskCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolTaskCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolTaskCacheResp.Merge(m, src)
}
func (m *GetSocolTaskCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolTaskCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolTaskCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolTaskCacheResp proto.InternalMessageInfo

func (m *GetSocolTaskCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *GetSocolTaskCacheResp) GetTaskCache() *SocolTaskCache {
	if m != nil {
		return m.TaskCache
	}
	return nil
}

func (m *GetSocolTaskCacheResp) GetImageList() []*SocolUploadImage {
	if m != nil {
		return m.ImageList
	}
	return nil
}

type UpdateSocolTaskCacheReq struct {
	IsDelete             int32               `protobuf:"varint,1,opt,name=is_delete,json=isDelete,proto3" json:"is_delete,omitempty"`
	CmdSeqList           []*SocolCmdSeq      `protobuf:"bytes,2,rep,name=cmd_seq_list,json=cmdSeqList,proto3" json:"cmd_seq_list,omitempty"`
	ImageList            []*SocolUploadImage `protobuf:"bytes,3,rep,name=image_list,json=imageList,proto3" json:"image_list,omitempty"`
	CmdStatus            *SocolCmdStatus     `protobuf:"bytes,4,opt,name=cmd_status,json=cmdStatus,proto3" json:"cmd_status,omitempty"`
	UploadMsg            *SocolUploadMessage `protobuf:"bytes,5,opt,name=upload_msg,json=uploadMsg,proto3" json:"upload_msg,omitempty"`
	UploadSummary        *SocolUploadSummary `protobuf:"bytes,6,opt,name=upload_summary,json=uploadSummary,proto3" json:"upload_summary,omitempty"`
	ExpiredTime          uint32              `protobuf:"varint,7,opt,name=expired_time,json=expiredTime,proto3" json:"expired_time,omitempty"`
	VersionCode          string              `protobuf:"bytes,8,opt,name=version_code,json=versionCode,proto3" json:"version_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *UpdateSocolTaskCacheReq) Reset()         { *m = UpdateSocolTaskCacheReq{} }
func (m *UpdateSocolTaskCacheReq) String() string { return proto.CompactTextString(m) }
func (*UpdateSocolTaskCacheReq) ProtoMessage()    {}
func (*UpdateSocolTaskCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{5}
}
func (m *UpdateSocolTaskCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSocolTaskCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSocolTaskCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSocolTaskCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSocolTaskCacheReq.Merge(m, src)
}
func (m *UpdateSocolTaskCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSocolTaskCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSocolTaskCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSocolTaskCacheReq proto.InternalMessageInfo

func (m *UpdateSocolTaskCacheReq) GetIsDelete() int32 {
	if m != nil {
		return m.IsDelete
	}
	return 0
}

func (m *UpdateSocolTaskCacheReq) GetCmdSeqList() []*SocolCmdSeq {
	if m != nil {
		return m.CmdSeqList
	}
	return nil
}

func (m *UpdateSocolTaskCacheReq) GetImageList() []*SocolUploadImage {
	if m != nil {
		return m.ImageList
	}
	return nil
}

func (m *UpdateSocolTaskCacheReq) GetCmdStatus() *SocolCmdStatus {
	if m != nil {
		return m.CmdStatus
	}
	return nil
}

func (m *UpdateSocolTaskCacheReq) GetUploadMsg() *SocolUploadMessage {
	if m != nil {
		return m.UploadMsg
	}
	return nil
}

func (m *UpdateSocolTaskCacheReq) GetUploadSummary() *SocolUploadSummary {
	if m != nil {
		return m.UploadSummary
	}
	return nil
}

func (m *UpdateSocolTaskCacheReq) GetExpiredTime() uint32 {
	if m != nil {
		return m.ExpiredTime
	}
	return 0
}

func (m *UpdateSocolTaskCacheReq) GetVersionCode() string {
	if m != nil {
		return m.VersionCode
	}
	return ""
}

type UpdateSocolTaskCacheResp struct {
	Base                 *BaseRespInfo `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdateSocolTaskCacheResp) Reset()         { *m = UpdateSocolTaskCacheResp{} }
func (m *UpdateSocolTaskCacheResp) String() string { return proto.CompactTextString(m) }
func (*UpdateSocolTaskCacheResp) ProtoMessage()    {}
func (*UpdateSocolTaskCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{6}
}
func (m *UpdateSocolTaskCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSocolTaskCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSocolTaskCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSocolTaskCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSocolTaskCacheResp.Merge(m, src)
}
func (m *UpdateSocolTaskCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSocolTaskCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSocolTaskCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSocolTaskCacheResp proto.InternalMessageInfo

func (m *UpdateSocolTaskCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

type GetSocolWillExpireTaskCacheReq struct {
	ExpiredTime          uint32   `protobuf:"varint,1,opt,name=expired_time,json=expiredTime,proto3" json:"expired_time,omitempty"`
	LockTime             uint32   `protobuf:"varint,2,opt,name=lock_time,json=lockTime,proto3" json:"lock_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSocolWillExpireTaskCacheReq) Reset()         { *m = GetSocolWillExpireTaskCacheReq{} }
func (m *GetSocolWillExpireTaskCacheReq) String() string { return proto.CompactTextString(m) }
func (*GetSocolWillExpireTaskCacheReq) ProtoMessage()    {}
func (*GetSocolWillExpireTaskCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{7}
}
func (m *GetSocolWillExpireTaskCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolWillExpireTaskCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolWillExpireTaskCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolWillExpireTaskCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolWillExpireTaskCacheReq.Merge(m, src)
}
func (m *GetSocolWillExpireTaskCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolWillExpireTaskCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolWillExpireTaskCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolWillExpireTaskCacheReq proto.InternalMessageInfo

func (m *GetSocolWillExpireTaskCacheReq) GetExpiredTime() uint32 {
	if m != nil {
		return m.ExpiredTime
	}
	return 0
}

func (m *GetSocolWillExpireTaskCacheReq) GetLockTime() uint32 {
	if m != nil {
		return m.LockTime
	}
	return 0
}

type GetSocolWillExpireTaskCacheResp struct {
	Base                 *BaseRespInfo  `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	CmdSeqList           []*SocolCmdSeq `protobuf:"bytes,2,rep,name=cmd_seq_list,json=cmdSeqList,proto3" json:"cmd_seq_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetSocolWillExpireTaskCacheResp) Reset()         { *m = GetSocolWillExpireTaskCacheResp{} }
func (m *GetSocolWillExpireTaskCacheResp) String() string { return proto.CompactTextString(m) }
func (*GetSocolWillExpireTaskCacheResp) ProtoMessage()    {}
func (*GetSocolWillExpireTaskCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{8}
}
func (m *GetSocolWillExpireTaskCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolWillExpireTaskCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolWillExpireTaskCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolWillExpireTaskCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolWillExpireTaskCacheResp.Merge(m, src)
}
func (m *GetSocolWillExpireTaskCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolWillExpireTaskCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolWillExpireTaskCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolWillExpireTaskCacheResp proto.InternalMessageInfo

func (m *GetSocolWillExpireTaskCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *GetSocolWillExpireTaskCacheResp) GetCmdSeqList() []*SocolCmdSeq {
	if m != nil {
		return m.CmdSeqList
	}
	return nil
}

type GetSocolDiagnoseCouterCacheReq struct {
	HoldId               uint32   `protobuf:"varint,1,opt,name=hold_id,json=holdId,proto3" json:"hold_id,omitempty"`
	DeviceId             uint32   `protobuf:"varint,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSocolDiagnoseCouterCacheReq) Reset()         { *m = GetSocolDiagnoseCouterCacheReq{} }
func (m *GetSocolDiagnoseCouterCacheReq) String() string { return proto.CompactTextString(m) }
func (*GetSocolDiagnoseCouterCacheReq) ProtoMessage()    {}
func (*GetSocolDiagnoseCouterCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{9}
}
func (m *GetSocolDiagnoseCouterCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolDiagnoseCouterCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolDiagnoseCouterCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolDiagnoseCouterCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolDiagnoseCouterCacheReq.Merge(m, src)
}
func (m *GetSocolDiagnoseCouterCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolDiagnoseCouterCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolDiagnoseCouterCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolDiagnoseCouterCacheReq proto.InternalMessageInfo

func (m *GetSocolDiagnoseCouterCacheReq) GetHoldId() uint32 {
	if m != nil {
		return m.HoldId
	}
	return 0
}

func (m *GetSocolDiagnoseCouterCacheReq) GetDeviceId() uint32 {
	if m != nil {
		return m.DeviceId
	}
	return 0
}

type GetSocolDiagnoseCouterCacheResp struct {
	Base                 *BaseRespInfo     `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	ImageTotal           uint32            `protobuf:"varint,2,opt,name=image_total,json=imageTotal,proto3" json:"image_total,omitempty"`
	HoldCounter          map[uint32]uint32 `protobuf:"bytes,3,rep,name=hold_counter,json=holdCounter,proto3" json:"hold_counter,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DeviceCounter        map[uint32]uint32 `protobuf:"bytes,4,rep,name=device_counter,json=deviceCounter,proto3" json:"device_counter,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetSocolDiagnoseCouterCacheResp) Reset()         { *m = GetSocolDiagnoseCouterCacheResp{} }
func (m *GetSocolDiagnoseCouterCacheResp) String() string { return proto.CompactTextString(m) }
func (*GetSocolDiagnoseCouterCacheResp) ProtoMessage()    {}
func (*GetSocolDiagnoseCouterCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{10}
}
func (m *GetSocolDiagnoseCouterCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolDiagnoseCouterCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolDiagnoseCouterCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolDiagnoseCouterCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolDiagnoseCouterCacheResp.Merge(m, src)
}
func (m *GetSocolDiagnoseCouterCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolDiagnoseCouterCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolDiagnoseCouterCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolDiagnoseCouterCacheResp proto.InternalMessageInfo

func (m *GetSocolDiagnoseCouterCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *GetSocolDiagnoseCouterCacheResp) GetImageTotal() uint32 {
	if m != nil {
		return m.ImageTotal
	}
	return 0
}

func (m *GetSocolDiagnoseCouterCacheResp) GetHoldCounter() map[uint32]uint32 {
	if m != nil {
		return m.HoldCounter
	}
	return nil
}

func (m *GetSocolDiagnoseCouterCacheResp) GetDeviceCounter() map[uint32]uint32 {
	if m != nil {
		return m.DeviceCounter
	}
	return nil
}

type SetSocolDiagnoseCouterCacheReq struct {
	HoldId               uint32   `protobuf:"varint,1,opt,name=hold_id,json=holdId,proto3" json:"hold_id,omitempty"`
	DeviceId             uint32   `protobuf:"varint,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	ImageCount           uint32   `protobuf:"varint,3,opt,name=image_count,json=imageCount,proto3" json:"image_count,omitempty"`
	WarnType             uint32   `protobuf:"varint,4,opt,name=warn_type,json=warnType,proto3" json:"warn_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetSocolDiagnoseCouterCacheReq) Reset()         { *m = SetSocolDiagnoseCouterCacheReq{} }
func (m *SetSocolDiagnoseCouterCacheReq) String() string { return proto.CompactTextString(m) }
func (*SetSocolDiagnoseCouterCacheReq) ProtoMessage()    {}
func (*SetSocolDiagnoseCouterCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{11}
}
func (m *SetSocolDiagnoseCouterCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSocolDiagnoseCouterCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSocolDiagnoseCouterCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSocolDiagnoseCouterCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSocolDiagnoseCouterCacheReq.Merge(m, src)
}
func (m *SetSocolDiagnoseCouterCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *SetSocolDiagnoseCouterCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSocolDiagnoseCouterCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetSocolDiagnoseCouterCacheReq proto.InternalMessageInfo

func (m *SetSocolDiagnoseCouterCacheReq) GetHoldId() uint32 {
	if m != nil {
		return m.HoldId
	}
	return 0
}

func (m *SetSocolDiagnoseCouterCacheReq) GetDeviceId() uint32 {
	if m != nil {
		return m.DeviceId
	}
	return 0
}

func (m *SetSocolDiagnoseCouterCacheReq) GetImageCount() uint32 {
	if m != nil {
		return m.ImageCount
	}
	return 0
}

func (m *SetSocolDiagnoseCouterCacheReq) GetWarnType() uint32 {
	if m != nil {
		return m.WarnType
	}
	return 0
}

type SetSocolDiagnoseCouterCacheResp struct {
	Base                 *BaseRespInfo `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SetSocolDiagnoseCouterCacheResp) Reset()         { *m = SetSocolDiagnoseCouterCacheResp{} }
func (m *SetSocolDiagnoseCouterCacheResp) String() string { return proto.CompactTextString(m) }
func (*SetSocolDiagnoseCouterCacheResp) ProtoMessage()    {}
func (*SetSocolDiagnoseCouterCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{12}
}
func (m *SetSocolDiagnoseCouterCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSocolDiagnoseCouterCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSocolDiagnoseCouterCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSocolDiagnoseCouterCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSocolDiagnoseCouterCacheResp.Merge(m, src)
}
func (m *SetSocolDiagnoseCouterCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *SetSocolDiagnoseCouterCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSocolDiagnoseCouterCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_SetSocolDiagnoseCouterCacheResp proto.InternalMessageInfo

func (m *SetSocolDiagnoseCouterCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

type SocolDiagnoseHoldWarnCounter struct {
	HoldId               uint32   `protobuf:"varint,1,opt,name=hold_id,json=holdId,proto3" json:"hold_id,omitempty"`
	WarnType             uint32   `protobuf:"varint,2,opt,name=warn_type,json=warnType,proto3" json:"warn_type,omitempty"`
	ImageTotal           uint32   `protobuf:"varint,3,opt,name=image_total,json=imageTotal,proto3" json:"image_total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SocolDiagnoseHoldWarnCounter) Reset()         { *m = SocolDiagnoseHoldWarnCounter{} }
func (m *SocolDiagnoseHoldWarnCounter) String() string { return proto.CompactTextString(m) }
func (*SocolDiagnoseHoldWarnCounter) ProtoMessage()    {}
func (*SocolDiagnoseHoldWarnCounter) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{13}
}
func (m *SocolDiagnoseHoldWarnCounter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SocolDiagnoseHoldWarnCounter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SocolDiagnoseHoldWarnCounter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SocolDiagnoseHoldWarnCounter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocolDiagnoseHoldWarnCounter.Merge(m, src)
}
func (m *SocolDiagnoseHoldWarnCounter) XXX_Size() int {
	return m.Size()
}
func (m *SocolDiagnoseHoldWarnCounter) XXX_DiscardUnknown() {
	xxx_messageInfo_SocolDiagnoseHoldWarnCounter.DiscardUnknown(m)
}

var xxx_messageInfo_SocolDiagnoseHoldWarnCounter proto.InternalMessageInfo

func (m *SocolDiagnoseHoldWarnCounter) GetHoldId() uint32 {
	if m != nil {
		return m.HoldId
	}
	return 0
}

func (m *SocolDiagnoseHoldWarnCounter) GetWarnType() uint32 {
	if m != nil {
		return m.WarnType
	}
	return 0
}

func (m *SocolDiagnoseHoldWarnCounter) GetImageTotal() uint32 {
	if m != nil {
		return m.ImageTotal
	}
	return 0
}

type GetSocolDiagnoseHoldWarnCouterCacheReq struct {
	HoldId               uint32   `protobuf:"varint,1,opt,name=hold_id,json=holdId,proto3" json:"hold_id,omitempty"`
	WarnType             uint32   `protobuf:"varint,2,opt,name=warn_type,json=warnType,proto3" json:"warn_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) Reset() {
	*m = GetSocolDiagnoseHoldWarnCouterCacheReq{}
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) String() string { return proto.CompactTextString(m) }
func (*GetSocolDiagnoseHoldWarnCouterCacheReq) ProtoMessage()    {}
func (*GetSocolDiagnoseHoldWarnCouterCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{14}
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolDiagnoseHoldWarnCouterCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolDiagnoseHoldWarnCouterCacheReq.Merge(m, src)
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolDiagnoseHoldWarnCouterCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolDiagnoseHoldWarnCouterCacheReq proto.InternalMessageInfo

func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) GetHoldId() uint32 {
	if m != nil {
		return m.HoldId
	}
	return 0
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) GetWarnType() uint32 {
	if m != nil {
		return m.WarnType
	}
	return 0
}

type GetSocolDiagnoseHoldWarnCouterCacheResp struct {
	Base                 *BaseRespInfo                   `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	CounterList          []*SocolDiagnoseHoldWarnCounter `protobuf:"bytes,2,rep,name=counter_list,json=counterList,proto3" json:"counter_list,omitempty"`
	CounterTotal         uint32                          `protobuf:"varint,3,opt,name=counter_total,json=counterTotal,proto3" json:"counter_total,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) Reset() {
	*m = GetSocolDiagnoseHoldWarnCouterCacheResp{}
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) String() string { return proto.CompactTextString(m) }
func (*GetSocolDiagnoseHoldWarnCouterCacheResp) ProtoMessage()    {}
func (*GetSocolDiagnoseHoldWarnCouterCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{15}
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolDiagnoseHoldWarnCouterCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolDiagnoseHoldWarnCouterCacheResp.Merge(m, src)
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolDiagnoseHoldWarnCouterCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolDiagnoseHoldWarnCouterCacheResp proto.InternalMessageInfo

func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) GetCounterList() []*SocolDiagnoseHoldWarnCounter {
	if m != nil {
		return m.CounterList
	}
	return nil
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) GetCounterTotal() uint32 {
	if m != nil {
		return m.CounterTotal
	}
	return 0
}

type GetSocolTryLockCacheReq struct {
	LockKey              string   `protobuf:"bytes,1,opt,name=lock_key,json=lockKey,proto3" json:"lock_key,omitempty"`
	LockToken            string   `protobuf:"bytes,2,opt,name=lock_token,json=lockToken,proto3" json:"lock_token,omitempty"`
	LockTtl              uint32   `protobuf:"varint,3,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSocolTryLockCacheReq) Reset()         { *m = GetSocolTryLockCacheReq{} }
func (m *GetSocolTryLockCacheReq) String() string { return proto.CompactTextString(m) }
func (*GetSocolTryLockCacheReq) ProtoMessage()    {}
func (*GetSocolTryLockCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{16}
}
func (m *GetSocolTryLockCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolTryLockCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolTryLockCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolTryLockCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolTryLockCacheReq.Merge(m, src)
}
func (m *GetSocolTryLockCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolTryLockCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolTryLockCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolTryLockCacheReq proto.InternalMessageInfo

func (m *GetSocolTryLockCacheReq) GetLockKey() string {
	if m != nil {
		return m.LockKey
	}
	return ""
}

func (m *GetSocolTryLockCacheReq) GetLockToken() string {
	if m != nil {
		return m.LockToken
	}
	return ""
}

func (m *GetSocolTryLockCacheReq) GetLockTtl() uint32 {
	if m != nil {
		return m.LockTtl
	}
	return 0
}

type GetSocolTryLockCacheResp struct {
	Base                 *BaseRespInfo `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetSocolTryLockCacheResp) Reset()         { *m = GetSocolTryLockCacheResp{} }
func (m *GetSocolTryLockCacheResp) String() string { return proto.CompactTextString(m) }
func (*GetSocolTryLockCacheResp) ProtoMessage()    {}
func (*GetSocolTryLockCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{17}
}
func (m *GetSocolTryLockCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSocolTryLockCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSocolTryLockCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSocolTryLockCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSocolTryLockCacheResp.Merge(m, src)
}
func (m *GetSocolTryLockCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *GetSocolTryLockCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSocolTryLockCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetSocolTryLockCacheResp proto.InternalMessageInfo

func (m *GetSocolTryLockCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

type SetSocolUnLockCacheReq struct {
	LockKey              string   `protobuf:"bytes,1,opt,name=lock_key,json=lockKey,proto3" json:"lock_key,omitempty"`
	LockToken            string   `protobuf:"bytes,2,opt,name=lock_token,json=lockToken,proto3" json:"lock_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetSocolUnLockCacheReq) Reset()         { *m = SetSocolUnLockCacheReq{} }
func (m *SetSocolUnLockCacheReq) String() string { return proto.CompactTextString(m) }
func (*SetSocolUnLockCacheReq) ProtoMessage()    {}
func (*SetSocolUnLockCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{18}
}
func (m *SetSocolUnLockCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSocolUnLockCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSocolUnLockCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSocolUnLockCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSocolUnLockCacheReq.Merge(m, src)
}
func (m *SetSocolUnLockCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *SetSocolUnLockCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSocolUnLockCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetSocolUnLockCacheReq proto.InternalMessageInfo

func (m *SetSocolUnLockCacheReq) GetLockKey() string {
	if m != nil {
		return m.LockKey
	}
	return ""
}

func (m *SetSocolUnLockCacheReq) GetLockToken() string {
	if m != nil {
		return m.LockToken
	}
	return ""
}

type SetSocolUnLockCacheResp struct {
	Base                 *BaseRespInfo `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SetSocolUnLockCacheResp) Reset()         { *m = SetSocolUnLockCacheResp{} }
func (m *SetSocolUnLockCacheResp) String() string { return proto.CompactTextString(m) }
func (*SetSocolUnLockCacheResp) ProtoMessage()    {}
func (*SetSocolUnLockCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{19}
}
func (m *SetSocolUnLockCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSocolUnLockCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSocolUnLockCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSocolUnLockCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSocolUnLockCacheResp.Merge(m, src)
}
func (m *SetSocolUnLockCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *SetSocolUnLockCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSocolUnLockCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_SetSocolUnLockCacheResp proto.InternalMessageInfo

func (m *SetSocolUnLockCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

type UpdateSocolRegisterStatCacheReq struct {
	DeviceSocol          *DeviceSocolInfo `protobuf:"bytes,1,opt,name=device_socol,json=deviceSocol,proto3" json:"device_socol,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UpdateSocolRegisterStatCacheReq) Reset()         { *m = UpdateSocolRegisterStatCacheReq{} }
func (m *UpdateSocolRegisterStatCacheReq) String() string { return proto.CompactTextString(m) }
func (*UpdateSocolRegisterStatCacheReq) ProtoMessage()    {}
func (*UpdateSocolRegisterStatCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{20}
}
func (m *UpdateSocolRegisterStatCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSocolRegisterStatCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSocolRegisterStatCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSocolRegisterStatCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSocolRegisterStatCacheReq.Merge(m, src)
}
func (m *UpdateSocolRegisterStatCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSocolRegisterStatCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSocolRegisterStatCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSocolRegisterStatCacheReq proto.InternalMessageInfo

func (m *UpdateSocolRegisterStatCacheReq) GetDeviceSocol() *DeviceSocolInfo {
	if m != nil {
		return m.DeviceSocol
	}
	return nil
}

type UpdateSocolRegisterStatCacheResp struct {
	Base                 *BaseRespInfo `protobuf:"bytes,1,opt,name=base,proto3" json:"base"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdateSocolRegisterStatCacheResp) Reset()         { *m = UpdateSocolRegisterStatCacheResp{} }
func (m *UpdateSocolRegisterStatCacheResp) String() string { return proto.CompactTextString(m) }
func (*UpdateSocolRegisterStatCacheResp) ProtoMessage()    {}
func (*UpdateSocolRegisterStatCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dbedd9d1b26c7e8, []int{21}
}
func (m *UpdateSocolRegisterStatCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSocolRegisterStatCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSocolRegisterStatCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSocolRegisterStatCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSocolRegisterStatCacheResp.Merge(m, src)
}
func (m *UpdateSocolRegisterStatCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSocolRegisterStatCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSocolRegisterStatCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSocolRegisterStatCacheResp proto.InternalMessageInfo

func (m *UpdateSocolRegisterStatCacheResp) GetBase() *BaseRespInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

func init() {
	proto.RegisterType((*SocolTaskCache)(nil), "mapgoo.paas.cap.socol.SocolTaskCache")
	proto.RegisterType((*SetSocolTaskCacheReq)(nil), "mapgoo.paas.cap.socol.SetSocolTaskCacheReq")
	proto.RegisterType((*SetSocolTaskCacheResp)(nil), "mapgoo.paas.cap.socol.SetSocolTaskCacheResp")
	proto.RegisterType((*GetSocolTaskCacheReq)(nil), "mapgoo.paas.cap.socol.GetSocolTaskCacheReq")
	proto.RegisterType((*GetSocolTaskCacheResp)(nil), "mapgoo.paas.cap.socol.GetSocolTaskCacheResp")
	proto.RegisterType((*UpdateSocolTaskCacheReq)(nil), "mapgoo.paas.cap.socol.UpdateSocolTaskCacheReq")
	proto.RegisterType((*UpdateSocolTaskCacheResp)(nil), "mapgoo.paas.cap.socol.UpdateSocolTaskCacheResp")
	proto.RegisterType((*GetSocolWillExpireTaskCacheReq)(nil), "mapgoo.paas.cap.socol.GetSocolWillExpireTaskCacheReq")
	proto.RegisterType((*GetSocolWillExpireTaskCacheResp)(nil), "mapgoo.paas.cap.socol.GetSocolWillExpireTaskCacheResp")
	proto.RegisterType((*GetSocolDiagnoseCouterCacheReq)(nil), "mapgoo.paas.cap.socol.GetSocolDiagnoseCouterCacheReq")
	proto.RegisterType((*GetSocolDiagnoseCouterCacheResp)(nil), "mapgoo.paas.cap.socol.GetSocolDiagnoseCouterCacheResp")
	proto.RegisterMapType((map[uint32]uint32)(nil), "mapgoo.paas.cap.socol.GetSocolDiagnoseCouterCacheResp.DeviceCounterEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "mapgoo.paas.cap.socol.GetSocolDiagnoseCouterCacheResp.HoldCounterEntry")
	proto.RegisterType((*SetSocolDiagnoseCouterCacheReq)(nil), "mapgoo.paas.cap.socol.SetSocolDiagnoseCouterCacheReq")
	proto.RegisterType((*SetSocolDiagnoseCouterCacheResp)(nil), "mapgoo.paas.cap.socol.SetSocolDiagnoseCouterCacheResp")
	proto.RegisterType((*SocolDiagnoseHoldWarnCounter)(nil), "mapgoo.paas.cap.socol.SocolDiagnoseHoldWarnCounter")
	proto.RegisterType((*GetSocolDiagnoseHoldWarnCouterCacheReq)(nil), "mapgoo.paas.cap.socol.GetSocolDiagnoseHoldWarnCouterCacheReq")
	proto.RegisterType((*GetSocolDiagnoseHoldWarnCouterCacheResp)(nil), "mapgoo.paas.cap.socol.GetSocolDiagnoseHoldWarnCouterCacheResp")
	proto.RegisterType((*GetSocolTryLockCacheReq)(nil), "mapgoo.paas.cap.socol.GetSocolTryLockCacheReq")
	proto.RegisterType((*GetSocolTryLockCacheResp)(nil), "mapgoo.paas.cap.socol.GetSocolTryLockCacheResp")
	proto.RegisterType((*SetSocolUnLockCacheReq)(nil), "mapgoo.paas.cap.socol.SetSocolUnLockCacheReq")
	proto.RegisterType((*SetSocolUnLockCacheResp)(nil), "mapgoo.paas.cap.socol.SetSocolUnLockCacheResp")
	proto.RegisterType((*UpdateSocolRegisterStatCacheReq)(nil), "mapgoo.paas.cap.socol.UpdateSocolRegisterStatCacheReq")
	proto.RegisterType((*UpdateSocolRegisterStatCacheResp)(nil), "mapgoo.paas.cap.socol.UpdateSocolRegisterStatCacheResp")
}

func init() { proto.RegisterFile("mapgoo.paas.cap.socol.proto", fileDescriptor_1dbedd9d1b26c7e8) }

var fileDescriptor_1dbedd9d1b26c7e8 = []byte{
	// 1348 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xef, 0xda, 0xf9, 0xe5, 0xe7, 0x24, 0xdf, 0x7e, 0x87, 0xa4, 0x31, 0x4e, 0xb0, 0xd3, 0x2d,
	0xa4, 0xe1, 0x47, 0xd7, 0x28, 0x15, 0x05, 0xa1, 0x52, 0xa1, 0x26, 0x51, 0x88, 0x68, 0xa5, 0xb2,
	0x76, 0x5a, 0xc4, 0x01, 0x77, 0xb2, 0x3b, 0xdd, 0x2c, 0x59, 0xef, 0x6c, 0x3d, 0xe3, 0x52, 0x5f,
	0xe1, 0x4f, 0xa0, 0x07, 0x0e, 0x1c, 0xb8, 0xc0, 0x91, 0xbf, 0x80, 0x03, 0x47, 0x8e, 0x48, 0x5c,
	0x11, 0xaa, 0x4a, 0x4f, 0xdc, 0xf8, 0x0f, 0xd0, 0xcc, 0xee, 0xc6, 0x6b, 0x7b, 0xd6, 0x76, 0xec,
	0x54, 0x5c, 0xda, 0x9d, 0x37, 0x33, 0xef, 0x7d, 0xde, 0xe7, 0xfd, 0x1a, 0x07, 0x56, 0x1b, 0x38,
	0x70, 0x28, 0x35, 0x02, 0x8c, 0x99, 0x61, 0xe1, 0xc0, 0x60, 0xd4, 0xa2, 0x9e, 0x11, 0x34, 0x29,
	0xa7, 0x68, 0x59, 0xb9, 0x59, 0xbc, 0x90, 0x14, 0x1f, 0x62, 0x46, 0xc2, 0xe3, 0xc5, 0xb5, 0xa4,
	0x3c, 0xd4, 0x63, 0x63, 0x8e, 0xa3, 0xdd, 0x2b, 0x8e, 0xcb, 0x8f, 0x5a, 0x87, 0x86, 0x45, 0x1b,
	0x15, 0x87, 0x3a, 0xb4, 0x22, 0xc5, 0x87, 0xad, 0x07, 0x72, 0x25, 0x17, 0xf2, 0x2b, 0x56, 0xe6,
	0x50, 0xea, 0x78, 0xa4, 0x82, 0x03, 0xb7, 0x82, 0x7d, 0x9f, 0x72, 0xcc, 0x5d, 0xea, 0xb3, 0x70,
	0x57, 0xff, 0x29, 0x0b, 0x8b, 0x55, 0x61, 0xa1, 0x86, 0xd9, 0xf1, 0x36, 0xb6, 0x8e, 0x08, 0x42,
	0x30, 0xe5, 0x36, 0x88, 0x5b, 0xd0, 0xd6, 0xb5, 0xcd, 0x9c, 0x29, 0xbf, 0xd1, 0x75, 0x98, 0xb5,
	0x1a, 0x76, 0x9d, 0x91, 0x87, 0x85, 0xcc, 0xba, 0xb6, 0x99, 0xdf, 0xba, 0x64, 0xa4, 0x60, 0x94,
	0xca, 0xb6, 0x1b, 0x76, 0x95, 0x3c, 0x34, 0x67, 0x2c, 0xf9, 0x3f, 0xda, 0x05, 0x90, 0xb7, 0x39,
	0xe6, 0x2d, 0x56, 0xc8, 0x4a, 0x05, 0x1b, 0x43, 0x15, 0xc8, 0xd3, 0x66, 0xce, 0x8a, 0x3f, 0x51,
	0x19, 0xf2, 0x1c, 0xb3, 0xe3, 0x58, 0xcf, 0xd4, 0xba, 0xb6, 0xb9, 0x60, 0x82, 0x10, 0x45, 0x07,
	0x2e, 0xc2, 0x3c, 0x79, 0x1c, 0xb8, 0x4d, 0x62, 0xd7, 0xb9, 0xdb, 0x20, 0x85, 0x69, 0x79, 0x22,
	0x1f, 0xc9, 0x6a, 0x6e, 0x83, 0xa0, 0x7d, 0x80, 0x56, 0xe0, 0x51, 0x6c, 0xd7, 0x1b, 0xcc, 0x29,
	0xcc, 0x48, 0x28, 0x6f, 0x0c, 0x84, 0x72, 0x20, 0x8f, 0xdf, 0x26, 0x8c, 0x61, 0x87, 0x98, 0xb9,
	0xf0, 0xf6, 0x6d, 0xe6, 0xa0, 0x4f, 0x60, 0x31, 0x52, 0xc5, 0x5a, 0x8d, 0x06, 0x6e, 0xb6, 0x0b,
	0xb3, 0x23, 0xab, 0xab, 0x86, 0x37, 0xcc, 0x85, 0x56, 0x72, 0x29, 0x1c, 0x78, 0x44, 0x9a, 0xcc,
	0xa5, 0x7e, 0xdd, 0xa2, 0x36, 0x29, 0xcc, 0xc9, 0x10, 0xe4, 0x23, 0xd9, 0x36, 0xb5, 0x89, 0xfe,
	0x83, 0x06, 0x4b, 0x55, 0xc2, 0xbb, 0x63, 0x66, 0x92, 0x87, 0x68, 0x07, 0x24, 0x15, 0x75, 0x4b,
	0x08, 0x64, 0xf0, 0xf2, 0x5b, 0xaf, 0x19, 0xea, 0xac, 0xec, 0xb9, 0x9d, 0xe3, 0x27, 0xc1, 0xdf,
	0x03, 0x70, 0x1b, 0xd8, 0x21, 0x75, 0xcf, 0x65, 0xbc, 0x90, 0x5d, 0xcf, 0x6e, 0xe6, 0xb7, 0x36,
	0x47, 0x70, 0x68, 0xbf, 0x21, 0xd9, 0x91, 0x77, 0x6f, 0xb9, 0x8c, 0xeb, 0x07, 0xb0, 0xac, 0x80,
	0xc9, 0x02, 0x74, 0x1d, 0xa6, 0x44, 0xaa, 0x47, 0x08, 0x4b, 0x46, 0x5f, 0x0d, 0xdc, 0xc4, 0x4c,
	0x9e, 0xdc, 0xf7, 0x1f, 0xd0, 0x9b, 0x73, 0x7f, 0xff, 0x59, 0x96, 0xe7, 0x4d, 0xf9, 0xaf, 0x5e,
	0x83, 0xa5, 0x3d, 0x95, 0xf7, 0x89, 0x04, 0xd5, 0x4e, 0x9d, 0xa0, 0xfa, 0x73, 0x0d, 0x96, 0xf7,
	0xce, 0x1e, 0x6d, 0x4f, 0x4c, 0x32, 0xff, 0x75, 0x4c, 0xfe, 0xc9, 0xc2, 0xca, 0x41, 0x60, 0x63,
	0x4e, 0xfa, 0x09, 0x5c, 0x85, 0x9c, 0xcb, 0xea, 0x36, 0xf1, 0x08, 0x0f, 0xbd, 0x9d, 0x36, 0xe7,
	0x5c, 0xb6, 0x23, 0xd7, 0x68, 0x17, 0xe6, 0x23, 0x76, 0x43, 0x0c, 0x19, 0x89, 0x61, 0x24, 0x8a,
	0x21, 0xa4, 0x58, 0xd8, 0x3f, 0x33, 0x47, 0x7a, 0x1a, 0xca, 0xd4, 0xb8, 0x0d, 0xa5, 0xbb, 0x19,
	0x4c, 0x9f, 0x6d, 0x33, 0x98, 0x39, 0x83, 0x66, 0xd0, 0xd5, 0xcd, 0x66, 0xfb, 0xbb, 0xd9, 0x08,
	0xfd, 0xe2, 0x53, 0x28, 0xa8, 0x43, 0x3e, 0x71, 0x29, 0xde, 0x87, 0x52, 0x5c, 0x33, 0xf7, 0x5c,
	0xcf, 0xdb, 0x95, 0xb8, 0xba, 0x72, 0xaa, 0xd7, 0x03, 0xad, 0xdf, 0x83, 0x55, 0xc8, 0x79, 0xd4,
	0x3a, 0x0e, 0xf7, 0x33, 0x72, 0x7f, 0x4e, 0x08, 0xc4, 0xa6, 0xfe, 0xa3, 0x06, 0xe5, 0x81, 0x26,
	0x26, 0x2e, 0xd0, 0xb3, 0x49, 0x6c, 0xfd, 0x6e, 0x87, 0x8a, 0x1d, 0x17, 0x3b, 0x3e, 0x65, 0x64,
	0x9b, 0xb6, 0x38, 0x69, 0x9e, 0x50, 0xb1, 0x02, 0xb3, 0x47, 0xd4, 0xb3, 0xeb, 0xae, 0x1d, 0xb1,
	0x30, 0x23, 0x96, 0xfb, 0xb6, 0x20, 0xc0, 0x26, 0x8f, 0x5c, 0x8b, 0x88, 0xad, 0x88, 0x80, 0x50,
	0xb0, 0x6f, 0xeb, 0x4f, 0xb3, 0x1d, 0x02, 0x94, 0x8a, 0x27, 0x26, 0xa0, 0x0c, 0xf9, 0xb0, 0x24,
	0x39, 0xe5, 0xd8, 0x8b, 0x00, 0x84, 0x55, 0x5a, 0x13, 0x12, 0xf4, 0x05, 0xcc, 0x4b, 0xe0, 0x16,
	0x6d, 0xf9, 0x9c, 0x34, 0xa3, 0xaa, 0xdd, 0x4b, 0x69, 0x62, 0x43, 0xc0, 0x1a, 0x1f, 0x51, 0xcf,
	0xde, 0x0e, 0x35, 0xed, 0xfa, 0xbc, 0xd9, 0x36, 0xf3, 0x47, 0x1d, 0x09, 0x0a, 0x60, 0x31, 0xe2,
	0x22, 0xb6, 0x36, 0x25, 0xad, 0xed, 0x8f, 0x69, 0x6d, 0x47, 0x2a, 0xeb, 0xb2, 0xb7, 0x60, 0x27,
	0x65, 0xc5, 0x1b, 0x70, 0xbe, 0x17, 0x12, 0x3a, 0x0f, 0xd9, 0x63, 0xd2, 0x8e, 0xc2, 0x24, 0x3e,
	0xd1, 0x12, 0x4c, 0x3f, 0xc2, 0x5e, 0x2b, 0x4e, 0xd0, 0x70, 0xf1, 0x7e, 0xe6, 0x3d, 0xad, 0xf8,
	0x21, 0xa0, 0x7e, 0x23, 0xa7, 0xd1, 0xa0, 0x3f, 0xd1, 0xa0, 0x54, 0x7d, 0x01, 0xb9, 0xd3, 0x89,
	0xac, 0xe4, 0x52, 0xbe, 0xba, 0xe2, 0xc8, 0x4a, 0xb0, 0xe2, 0xf6, 0x97, 0xb8, 0xe9, 0xd7, 0x79,
	0x3b, 0x20, 0xd1, 0x63, 0x6a, 0x4e, 0x08, 0x6a, 0xed, 0x80, 0xe8, 0x75, 0x28, 0x57, 0x5f, 0x64,
	0xe2, 0xe9, 0x2d, 0x58, 0xeb, 0xd2, 0x2e, 0xc2, 0x70, 0x0f, 0x37, 0xfd, 0x38, 0x17, 0x06, 0x39,
	0xdd, 0x81, 0x9d, 0xe9, 0x86, 0xdd, 0x9b, 0xce, 0xd9, 0xde, 0x74, 0xd6, 0x3f, 0x87, 0x8d, 0xde,
	0xac, 0x49, 0x58, 0x1e, 0x95, 0xf5, 0x54, 0x00, 0xe2, 0x25, 0x71, 0x79, 0x24, 0x03, 0x13, 0x57,
	0xee, 0x5d, 0x98, 0x8f, 0xaa, 0x24, 0xd9, 0xba, 0xae, 0x0e, 0x7a, 0x5d, 0xa4, 0x70, 0x6d, 0xe6,
	0x23, 0x45, 0x72, 0xb6, 0x5e, 0x82, 0x85, 0x58, 0x6f, 0x92, 0xc4, 0xd8, 0x58, 0x48, 0xa3, 0x0f,
	0x2b, 0x27, 0xef, 0xa5, 0x66, 0xfb, 0x16, 0xb5, 0x3a, 0x4d, 0xff, 0x65, 0x90, 0x0d, 0xbc, 0x1e,
	0x57, 0x40, 0xce, 0x9c, 0x15, 0xeb, 0x8f, 0x49, 0x1b, 0xbd, 0x02, 0x10, 0x36, 0x7b, 0x7a, 0x4c,
	0x7c, 0x49, 0x5d, 0xce, 0x94, 0xed, 0xbf, 0x26, 0x04, 0x27, 0x37, 0x39, 0x8f, 0x8d, 0xca, 0x9b,
	0x35, 0xee, 0x89, 0x29, 0xa6, 0xb6, 0x37, 0x71, 0x1e, 0x9a, 0x70, 0x21, 0x4e, 0xf4, 0x03, 0xff,
	0x6c, 0x1c, 0xd1, 0xef, 0xc1, 0x8a, 0x52, 0xe7, 0xc4, 0x60, 0x1d, 0x28, 0x27, 0x86, 0xb9, 0x49,
	0x1c, 0x97, 0x71, 0xd2, 0x14, 0xaf, 0x99, 0xc4, 0xcf, 0x80, 0xf9, 0xa8, 0x27, 0xc8, 0xc0, 0x47,
	0x86, 0x2e, 0xf6, 0x1b, 0x0a, 0xfb, 0x96, 0x54, 0x24, 0x6c, 0x99, 0x79, 0xbb, 0x23, 0xd0, 0xef,
	0xc3, 0xfa, 0x60, 0x43, 0x93, 0xba, 0xb2, 0xf5, 0xf5, 0x22, 0xfc, 0x2f, 0x1c, 0xa7, 0x42, 0xe1,
	0x9d, 0x26, 0x7d, 0xdc, 0x46, 0x4f, 0x34, 0xf8, 0x3f, 0xeb, 0x7d, 0x86, 0xa3, 0x37, 0xd3, 0x52,
	0x5a, 0xf1, 0x3b, 0xa0, 0xf8, 0xd6, 0xe8, 0x87, 0x59, 0xa0, 0xbf, 0xfa, 0xd5, 0xef, 0xcf, 0xbf,
	0xc9, 0x94, 0xd0, 0x5a, 0xc5, 0xc2, 0x41, 0x45, 0x9e, 0xac, 0xf4, 0x03, 0x10, 0xb0, 0x9c, 0x91,
	0x61, 0xed, 0x9d, 0x06, 0xd6, 0xde, 0xc8, 0xb0, 0xfa, 0x01, 0x7c, 0xaf, 0xc1, 0x92, 0xea, 0x69,
	0x87, 0x8c, 0x14, 0x63, 0x29, 0x4f, 0xff, 0x62, 0xe5, 0x54, 0xe7, 0x59, 0xa0, 0x5f, 0x96, 0xf8,
	0x2e, 0xa2, 0x72, 0x02, 0x5f, 0x4b, 0x85, 0xe4, 0x67, 0x0d, 0x56, 0x9d, 0xf4, 0x07, 0x1c, 0x7a,
	0x67, 0x08, 0x2d, 0xea, 0x77, 0x65, 0xf1, 0xda, 0x38, 0xd7, 0x58, 0xa0, 0x1b, 0x12, 0xf7, 0x26,
	0xda, 0x50, 0xf0, 0xaa, 0x82, 0x97, 0x84, 0xaf, 0x98, 0x82, 0x43, 0xe1, 0xab, 0xe7, 0xf9, 0x50,
	0xf8, 0x29, 0x03, 0x77, 0x20, 0x7c, 0x15, 0xbc, 0x3f, 0x34, 0xb8, 0xe4, 0x0c, 0x9f, 0x45, 0xe8,
	0x83, 0x11, 0xf1, 0xa8, 0x07, 0x65, 0xf1, 0xc6, 0x24, 0xd7, 0x59, 0xa0, 0x5f, 0x93, 0x6e, 0xbd,
	0x8d, 0x8c, 0x01, 0x6e, 0xa9, 0x60, 0x8b, 0xe8, 0xb0, 0x31, 0xa2, 0x53, 0x1d, 0x2f, 0x3a, 0xd5,
	0x31, 0xa2, 0x33, 0x08, 0x9e, 0x28, 0x5f, 0x47, 0x31, 0xd3, 0x52, 0xcb, 0x37, 0x65, 0xe0, 0xa6,
	0x96, 0x6f, 0xda, 0xc0, 0x54, 0x96, 0xaf, 0x12, 0xc9, 0x77, 0x1a, 0xbc, 0xc4, 0xfa, 0x07, 0x19,
	0xba, 0x32, 0x84, 0xa2, 0xee, 0x41, 0x5a, 0x34, 0x4e, 0x73, 0x9c, 0x05, 0xfa, 0x86, 0xc4, 0xb7,
	0x8e, 0x4a, 0x0a, 0x26, 0x93, 0x30, 0x7e, 0xd1, 0x60, 0xad, 0x35, 0x60, 0x4a, 0xa1, 0x6b, 0xc3,
	0x1b, 0x9b, 0x6a, 0x86, 0x16, 0xdf, 0x1d, 0xeb, 0x1e, 0x0b, 0xf4, 0x8a, 0x44, 0xfe, 0x3a, 0xba,
	0xac, 0x6e, 0x8c, 0x7d, 0x97, 0x6e, 0x2e, 0xff, 0xfa, 0xac, 0xa4, 0xfd, 0xf6, 0xac, 0xa4, 0x3d,
	0x7d, 0x56, 0xd2, 0xbe, 0xfd, 0xab, 0x74, 0xee, 0xb3, 0x2c, 0x0e, 0xdc, 0x3b, 0xe7, 0xee, 0x68,
	0x87, 0x33, 0xf2, 0x0f, 0xb4, 0x57, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xca, 0x6b, 0xc3, 0x15,
	0x59, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SocolCacheProxyClient is the client API for SocolCacheProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SocolCacheProxyClient interface {
	// 添加socol任务缓存
	SetSocolTaskCache(ctx context.Context, in *SetSocolTaskCacheReq, opts ...grpc.CallOption) (*SetSocolTaskCacheResp, error)
	// 获取socol任务缓存
	GetSocolTaskCache(ctx context.Context, in *GetSocolTaskCacheReq, opts ...grpc.CallOption) (*GetSocolTaskCacheResp, error)
	// 更新socol任务缓存
	UpdateSocolTaskCache(ctx context.Context, in *UpdateSocolTaskCacheReq, opts ...grpc.CallOption) (*UpdateSocolTaskCacheResp, error)
	// 获取socol快过期任务列表
	GetSocolWillExpireTaskCache(ctx context.Context, in *GetSocolWillExpireTaskCacheReq, opts ...grpc.CallOption) (*GetSocolWillExpireTaskCacheResp, error)
	// 获取Socol诊断计数
	GetSocolDiagnoseCouterCache(ctx context.Context, in *GetSocolDiagnoseCouterCacheReq, opts ...grpc.CallOption) (*GetSocolDiagnoseCouterCacheResp, error)
	// 获取Socol渠道预警诊断计数
	GetSocolDiagnoseHoldWarnCouterCache(ctx context.Context, in *GetSocolDiagnoseHoldWarnCouterCacheReq, opts ...grpc.CallOption) (*GetSocolDiagnoseHoldWarnCouterCacheResp, error)
	// 保存Socol诊断计数
	SetSocolDiagnoseCouterCache(ctx context.Context, in *SetSocolDiagnoseCouterCacheReq, opts ...grpc.CallOption) (*SetSocolDiagnoseCouterCacheResp, error)
	// Socol分布式加锁
	GetSocolTryLockCache(ctx context.Context, in *GetSocolTryLockCacheReq, opts ...grpc.CallOption) (*GetSocolTryLockCacheResp, error)
	// Socol分布式解锁
	SetSocolUnLockCache(ctx context.Context, in *SetSocolUnLockCacheReq, opts ...grpc.CallOption) (*SetSocolUnLockCacheResp, error)
	UpdateSocolRegisterStatCache(ctx context.Context, in *UpdateSocolRegisterStatCacheReq, opts ...grpc.CallOption) (*UpdateSocolRegisterStatCacheResp, error)
}

type socolCacheProxyClient struct {
	cc *grpc.ClientConn
}

func NewSocolCacheProxyClient(cc *grpc.ClientConn) SocolCacheProxyClient {
	return &socolCacheProxyClient{cc}
}

func (c *socolCacheProxyClient) SetSocolTaskCache(ctx context.Context, in *SetSocolTaskCacheReq, opts ...grpc.CallOption) (*SetSocolTaskCacheResp, error) {
	out := new(SetSocolTaskCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/setSocolTaskCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socolCacheProxyClient) GetSocolTaskCache(ctx context.Context, in *GetSocolTaskCacheReq, opts ...grpc.CallOption) (*GetSocolTaskCacheResp, error) {
	out := new(GetSocolTaskCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/getSocolTaskCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socolCacheProxyClient) UpdateSocolTaskCache(ctx context.Context, in *UpdateSocolTaskCacheReq, opts ...grpc.CallOption) (*UpdateSocolTaskCacheResp, error) {
	out := new(UpdateSocolTaskCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/UpdateSocolTaskCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socolCacheProxyClient) GetSocolWillExpireTaskCache(ctx context.Context, in *GetSocolWillExpireTaskCacheReq, opts ...grpc.CallOption) (*GetSocolWillExpireTaskCacheResp, error) {
	out := new(GetSocolWillExpireTaskCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/getSocolWillExpireTaskCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socolCacheProxyClient) GetSocolDiagnoseCouterCache(ctx context.Context, in *GetSocolDiagnoseCouterCacheReq, opts ...grpc.CallOption) (*GetSocolDiagnoseCouterCacheResp, error) {
	out := new(GetSocolDiagnoseCouterCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/getSocolDiagnoseCouterCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socolCacheProxyClient) GetSocolDiagnoseHoldWarnCouterCache(ctx context.Context, in *GetSocolDiagnoseHoldWarnCouterCacheReq, opts ...grpc.CallOption) (*GetSocolDiagnoseHoldWarnCouterCacheResp, error) {
	out := new(GetSocolDiagnoseHoldWarnCouterCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/getSocolDiagnoseHoldWarnCouterCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socolCacheProxyClient) SetSocolDiagnoseCouterCache(ctx context.Context, in *SetSocolDiagnoseCouterCacheReq, opts ...grpc.CallOption) (*SetSocolDiagnoseCouterCacheResp, error) {
	out := new(SetSocolDiagnoseCouterCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/setSocolDiagnoseCouterCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socolCacheProxyClient) GetSocolTryLockCache(ctx context.Context, in *GetSocolTryLockCacheReq, opts ...grpc.CallOption) (*GetSocolTryLockCacheResp, error) {
	out := new(GetSocolTryLockCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/getSocolTryLockCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socolCacheProxyClient) SetSocolUnLockCache(ctx context.Context, in *SetSocolUnLockCacheReq, opts ...grpc.CallOption) (*SetSocolUnLockCacheResp, error) {
	out := new(SetSocolUnLockCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/setSocolUnLockCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socolCacheProxyClient) UpdateSocolRegisterStatCache(ctx context.Context, in *UpdateSocolRegisterStatCacheReq, opts ...grpc.CallOption) (*UpdateSocolRegisterStatCacheResp, error) {
	out := new(UpdateSocolRegisterStatCacheResp)
	err := c.cc.Invoke(ctx, "/mapgoo.paas.cap.socol.SocolCacheProxy/updateSocolRegisterStatCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SocolCacheProxyServer is the server API for SocolCacheProxy service.
type SocolCacheProxyServer interface {
	// 添加socol任务缓存
	SetSocolTaskCache(context.Context, *SetSocolTaskCacheReq) (*SetSocolTaskCacheResp, error)
	// 获取socol任务缓存
	GetSocolTaskCache(context.Context, *GetSocolTaskCacheReq) (*GetSocolTaskCacheResp, error)
	// 更新socol任务缓存
	UpdateSocolTaskCache(context.Context, *UpdateSocolTaskCacheReq) (*UpdateSocolTaskCacheResp, error)
	// 获取socol快过期任务列表
	GetSocolWillExpireTaskCache(context.Context, *GetSocolWillExpireTaskCacheReq) (*GetSocolWillExpireTaskCacheResp, error)
	// 获取Socol诊断计数
	GetSocolDiagnoseCouterCache(context.Context, *GetSocolDiagnoseCouterCacheReq) (*GetSocolDiagnoseCouterCacheResp, error)
	// 获取Socol渠道预警诊断计数
	GetSocolDiagnoseHoldWarnCouterCache(context.Context, *GetSocolDiagnoseHoldWarnCouterCacheReq) (*GetSocolDiagnoseHoldWarnCouterCacheResp, error)
	// 保存Socol诊断计数
	SetSocolDiagnoseCouterCache(context.Context, *SetSocolDiagnoseCouterCacheReq) (*SetSocolDiagnoseCouterCacheResp, error)
	// Socol分布式加锁
	GetSocolTryLockCache(context.Context, *GetSocolTryLockCacheReq) (*GetSocolTryLockCacheResp, error)
	// Socol分布式解锁
	SetSocolUnLockCache(context.Context, *SetSocolUnLockCacheReq) (*SetSocolUnLockCacheResp, error)
	UpdateSocolRegisterStatCache(context.Context, *UpdateSocolRegisterStatCacheReq) (*UpdateSocolRegisterStatCacheResp, error)
}

// UnimplementedSocolCacheProxyServer can be embedded to have forward compatible implementations.
type UnimplementedSocolCacheProxyServer struct {
}

func (*UnimplementedSocolCacheProxyServer) SetSocolTaskCache(ctx context.Context, req *SetSocolTaskCacheReq) (*SetSocolTaskCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSocolTaskCache not implemented")
}
func (*UnimplementedSocolCacheProxyServer) GetSocolTaskCache(ctx context.Context, req *GetSocolTaskCacheReq) (*GetSocolTaskCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSocolTaskCache not implemented")
}
func (*UnimplementedSocolCacheProxyServer) UpdateSocolTaskCache(ctx context.Context, req *UpdateSocolTaskCacheReq) (*UpdateSocolTaskCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSocolTaskCache not implemented")
}
func (*UnimplementedSocolCacheProxyServer) GetSocolWillExpireTaskCache(ctx context.Context, req *GetSocolWillExpireTaskCacheReq) (*GetSocolWillExpireTaskCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSocolWillExpireTaskCache not implemented")
}
func (*UnimplementedSocolCacheProxyServer) GetSocolDiagnoseCouterCache(ctx context.Context, req *GetSocolDiagnoseCouterCacheReq) (*GetSocolDiagnoseCouterCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSocolDiagnoseCouterCache not implemented")
}
func (*UnimplementedSocolCacheProxyServer) GetSocolDiagnoseHoldWarnCouterCache(ctx context.Context, req *GetSocolDiagnoseHoldWarnCouterCacheReq) (*GetSocolDiagnoseHoldWarnCouterCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSocolDiagnoseHoldWarnCouterCache not implemented")
}
func (*UnimplementedSocolCacheProxyServer) SetSocolDiagnoseCouterCache(ctx context.Context, req *SetSocolDiagnoseCouterCacheReq) (*SetSocolDiagnoseCouterCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSocolDiagnoseCouterCache not implemented")
}
func (*UnimplementedSocolCacheProxyServer) GetSocolTryLockCache(ctx context.Context, req *GetSocolTryLockCacheReq) (*GetSocolTryLockCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSocolTryLockCache not implemented")
}
func (*UnimplementedSocolCacheProxyServer) SetSocolUnLockCache(ctx context.Context, req *SetSocolUnLockCacheReq) (*SetSocolUnLockCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSocolUnLockCache not implemented")
}
func (*UnimplementedSocolCacheProxyServer) UpdateSocolRegisterStatCache(ctx context.Context, req *UpdateSocolRegisterStatCacheReq) (*UpdateSocolRegisterStatCacheResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSocolRegisterStatCache not implemented")
}

func RegisterSocolCacheProxyServer(s *grpc.Server, srv SocolCacheProxyServer) {
	s.RegisterService(&_SocolCacheProxy_serviceDesc, srv)
}

func _SocolCacheProxy_SetSocolTaskCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSocolTaskCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).SetSocolTaskCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/SetSocolTaskCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).SetSocolTaskCache(ctx, req.(*SetSocolTaskCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SocolCacheProxy_GetSocolTaskCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSocolTaskCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).GetSocolTaskCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/GetSocolTaskCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).GetSocolTaskCache(ctx, req.(*GetSocolTaskCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SocolCacheProxy_UpdateSocolTaskCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSocolTaskCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).UpdateSocolTaskCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/UpdateSocolTaskCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).UpdateSocolTaskCache(ctx, req.(*UpdateSocolTaskCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SocolCacheProxy_GetSocolWillExpireTaskCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSocolWillExpireTaskCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).GetSocolWillExpireTaskCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/GetSocolWillExpireTaskCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).GetSocolWillExpireTaskCache(ctx, req.(*GetSocolWillExpireTaskCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SocolCacheProxy_GetSocolDiagnoseCouterCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSocolDiagnoseCouterCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).GetSocolDiagnoseCouterCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/GetSocolDiagnoseCouterCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).GetSocolDiagnoseCouterCache(ctx, req.(*GetSocolDiagnoseCouterCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SocolCacheProxy_GetSocolDiagnoseHoldWarnCouterCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSocolDiagnoseHoldWarnCouterCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).GetSocolDiagnoseHoldWarnCouterCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/GetSocolDiagnoseHoldWarnCouterCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).GetSocolDiagnoseHoldWarnCouterCache(ctx, req.(*GetSocolDiagnoseHoldWarnCouterCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SocolCacheProxy_SetSocolDiagnoseCouterCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSocolDiagnoseCouterCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).SetSocolDiagnoseCouterCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/SetSocolDiagnoseCouterCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).SetSocolDiagnoseCouterCache(ctx, req.(*SetSocolDiagnoseCouterCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SocolCacheProxy_GetSocolTryLockCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSocolTryLockCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).GetSocolTryLockCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/GetSocolTryLockCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).GetSocolTryLockCache(ctx, req.(*GetSocolTryLockCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SocolCacheProxy_SetSocolUnLockCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSocolUnLockCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).SetSocolUnLockCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/SetSocolUnLockCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).SetSocolUnLockCache(ctx, req.(*SetSocolUnLockCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SocolCacheProxy_UpdateSocolRegisterStatCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSocolRegisterStatCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocolCacheProxyServer).UpdateSocolRegisterStatCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mapgoo.paas.cap.socol.SocolCacheProxy/UpdateSocolRegisterStatCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocolCacheProxyServer).UpdateSocolRegisterStatCache(ctx, req.(*UpdateSocolRegisterStatCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _SocolCacheProxy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mapgoo.paas.cap.socol.SocolCacheProxy",
	HandlerType: (*SocolCacheProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "setSocolTaskCache",
			Handler:    _SocolCacheProxy_SetSocolTaskCache_Handler,
		},
		{
			MethodName: "getSocolTaskCache",
			Handler:    _SocolCacheProxy_GetSocolTaskCache_Handler,
		},
		{
			MethodName: "UpdateSocolTaskCache",
			Handler:    _SocolCacheProxy_UpdateSocolTaskCache_Handler,
		},
		{
			MethodName: "getSocolWillExpireTaskCache",
			Handler:    _SocolCacheProxy_GetSocolWillExpireTaskCache_Handler,
		},
		{
			MethodName: "getSocolDiagnoseCouterCache",
			Handler:    _SocolCacheProxy_GetSocolDiagnoseCouterCache_Handler,
		},
		{
			MethodName: "getSocolDiagnoseHoldWarnCouterCache",
			Handler:    _SocolCacheProxy_GetSocolDiagnoseHoldWarnCouterCache_Handler,
		},
		{
			MethodName: "setSocolDiagnoseCouterCache",
			Handler:    _SocolCacheProxy_SetSocolDiagnoseCouterCache_Handler,
		},
		{
			MethodName: "getSocolTryLockCache",
			Handler:    _SocolCacheProxy_GetSocolTryLockCache_Handler,
		},
		{
			MethodName: "setSocolUnLockCache",
			Handler:    _SocolCacheProxy_SetSocolUnLockCache_Handler,
		},
		{
			MethodName: "updateSocolRegisterStatCache",
			Handler:    _SocolCacheProxy_UpdateSocolRegisterStatCache_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mapgoo.paas.cap.socol.proto",
}

func (m *SocolTaskCache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocolTaskCache) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SocolTaskCache) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VersionCode) > 0 {
		i -= len(m.VersionCode)
		copy(dAtA[i:], m.VersionCode)
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(len(m.VersionCode)))
		i--
		dAtA[i] = 0x42
	}
	if m.UploadSummary != nil {
		{
			size, err := m.UploadSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.UploadMsg != nil {
		{
			size, err := m.UploadMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ExpiredTime != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.ExpiredTime))
		i--
		dAtA[i] = 0x28
	}
	if m.TaskStatus != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.TaskStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.CmdStatus != nil {
		{
			size, err := m.CmdStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CmdSeq != nil {
		{
			size, err := m.CmdSeq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Imei) > 0 {
		i -= len(m.Imei)
		copy(dAtA[i:], m.Imei)
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(len(m.Imei)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetSocolTaskCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSocolTaskCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSocolTaskCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ImageList) > 0 {
		for iNdEx := len(m.ImageList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImageList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TaskCache != nil {
		{
			size, err := m.TaskCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetSocolTaskCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSocolTaskCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSocolTaskCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolTaskCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolTaskCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolTaskCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CmdSeq != nil {
		{
			size, err := m.CmdSeq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolTaskCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolTaskCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolTaskCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ImageList) > 0 {
		for iNdEx := len(m.ImageList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImageList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TaskCache != nil {
		{
			size, err := m.TaskCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSocolTaskCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSocolTaskCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSocolTaskCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VersionCode) > 0 {
		i -= len(m.VersionCode)
		copy(dAtA[i:], m.VersionCode)
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(len(m.VersionCode)))
		i--
		dAtA[i] = 0x42
	}
	if m.ExpiredTime != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.ExpiredTime))
		i--
		dAtA[i] = 0x38
	}
	if m.UploadSummary != nil {
		{
			size, err := m.UploadSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UploadMsg != nil {
		{
			size, err := m.UploadMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CmdStatus != nil {
		{
			size, err := m.CmdStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ImageList) > 0 {
		for iNdEx := len(m.ImageList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImageList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CmdSeqList) > 0 {
		for iNdEx := len(m.CmdSeqList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CmdSeqList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.IsDelete != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.IsDelete))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSocolTaskCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSocolTaskCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSocolTaskCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolWillExpireTaskCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolWillExpireTaskCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolWillExpireTaskCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LockTime != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.LockTime))
		i--
		dAtA[i] = 0x10
	}
	if m.ExpiredTime != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.ExpiredTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolWillExpireTaskCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolWillExpireTaskCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolWillExpireTaskCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CmdSeqList) > 0 {
		for iNdEx := len(m.CmdSeqList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CmdSeqList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolDiagnoseCouterCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolDiagnoseCouterCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolDiagnoseCouterCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeviceId != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.DeviceId))
		i--
		dAtA[i] = 0x10
	}
	if m.HoldId != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.HoldId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolDiagnoseCouterCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolDiagnoseCouterCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolDiagnoseCouterCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceCounter) > 0 {
		for k := range m.DeviceCounter {
			v := m.DeviceCounter[k]
			baseI := i
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.HoldCounter) > 0 {
		for k := range m.HoldCounter {
			v := m.HoldCounter[k]
			baseI := i
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ImageTotal != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.ImageTotal))
		i--
		dAtA[i] = 0x10
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetSocolDiagnoseCouterCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSocolDiagnoseCouterCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSocolDiagnoseCouterCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WarnType != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.WarnType))
		i--
		dAtA[i] = 0x20
	}
	if m.ImageCount != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.ImageCount))
		i--
		dAtA[i] = 0x18
	}
	if m.DeviceId != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.DeviceId))
		i--
		dAtA[i] = 0x10
	}
	if m.HoldId != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.HoldId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetSocolDiagnoseCouterCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSocolDiagnoseCouterCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSocolDiagnoseCouterCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SocolDiagnoseHoldWarnCounter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocolDiagnoseHoldWarnCounter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SocolDiagnoseHoldWarnCounter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImageTotal != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.ImageTotal))
		i--
		dAtA[i] = 0x18
	}
	if m.WarnType != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.WarnType))
		i--
		dAtA[i] = 0x10
	}
	if m.HoldId != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.HoldId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WarnType != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.WarnType))
		i--
		dAtA[i] = 0x10
	}
	if m.HoldId != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.HoldId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CounterTotal != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.CounterTotal))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CounterList) > 0 {
		for iNdEx := len(m.CounterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CounterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolTryLockCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolTryLockCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolTryLockCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LockTtl != 0 {
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(m.LockTtl))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LockToken) > 0 {
		i -= len(m.LockToken)
		copy(dAtA[i:], m.LockToken)
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(len(m.LockToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LockKey) > 0 {
		i -= len(m.LockKey)
		copy(dAtA[i:], m.LockKey)
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(len(m.LockKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSocolTryLockCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSocolTryLockCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSocolTryLockCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetSocolUnLockCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSocolUnLockCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSocolUnLockCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LockToken) > 0 {
		i -= len(m.LockToken)
		copy(dAtA[i:], m.LockToken)
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(len(m.LockToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LockKey) > 0 {
		i -= len(m.LockKey)
		copy(dAtA[i:], m.LockKey)
		i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(len(m.LockKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetSocolUnLockCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSocolUnLockCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSocolUnLockCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSocolRegisterStatCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSocolRegisterStatCacheReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSocolRegisterStatCacheReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeviceSocol != nil {
		{
			size, err := m.DeviceSocol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSocolRegisterStatCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSocolRegisterStatCacheResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSocolRegisterStatCacheResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapgooPaasCapSocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMapgooPaasCapSocol(dAtA []byte, offset int, v uint64) int {
	offset -= sovMapgooPaasCapSocol(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SocolTaskCache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Imei)
	if l > 0 {
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.CmdSeq != nil {
		l = m.CmdSeq.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.CmdStatus != nil {
		l = m.CmdStatus.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.TaskStatus != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.TaskStatus))
	}
	if m.ExpiredTime != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.ExpiredTime))
	}
	if m.UploadMsg != nil {
		l = m.UploadMsg.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.UploadSummary != nil {
		l = m.UploadSummary.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	l = len(m.VersionCode)
	if l > 0 {
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetSocolTaskCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskCache != nil {
		l = m.TaskCache.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if len(m.ImageList) > 0 {
		for _, e := range m.ImageList {
			l = e.Size()
			n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetSocolTaskCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolTaskCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdSeq != nil {
		l = m.CmdSeq.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolTaskCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.TaskCache != nil {
		l = m.TaskCache.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if len(m.ImageList) > 0 {
		for _, e := range m.ImageList {
			l = e.Size()
			n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateSocolTaskCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsDelete != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.IsDelete))
	}
	if len(m.CmdSeqList) > 0 {
		for _, e := range m.CmdSeqList {
			l = e.Size()
			n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
		}
	}
	if len(m.ImageList) > 0 {
		for _, e := range m.ImageList {
			l = e.Size()
			n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
		}
	}
	if m.CmdStatus != nil {
		l = m.CmdStatus.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.UploadMsg != nil {
		l = m.UploadMsg.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.UploadSummary != nil {
		l = m.UploadSummary.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.ExpiredTime != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.ExpiredTime))
	}
	l = len(m.VersionCode)
	if l > 0 {
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateSocolTaskCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolWillExpireTaskCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiredTime != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.ExpiredTime))
	}
	if m.LockTime != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.LockTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolWillExpireTaskCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if len(m.CmdSeqList) > 0 {
		for _, e := range m.CmdSeqList {
			l = e.Size()
			n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolDiagnoseCouterCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HoldId != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.HoldId))
	}
	if m.DeviceId != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.DeviceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolDiagnoseCouterCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.ImageTotal != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.ImageTotal))
	}
	if len(m.HoldCounter) > 0 {
		for k, v := range m.HoldCounter {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMapgooPaasCapSocol(uint64(k)) + 1 + sovMapgooPaasCapSocol(uint64(v))
			n += mapEntrySize + 1 + sovMapgooPaasCapSocol(uint64(mapEntrySize))
		}
	}
	if len(m.DeviceCounter) > 0 {
		for k, v := range m.DeviceCounter {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMapgooPaasCapSocol(uint64(k)) + 1 + sovMapgooPaasCapSocol(uint64(v))
			n += mapEntrySize + 1 + sovMapgooPaasCapSocol(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetSocolDiagnoseCouterCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HoldId != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.HoldId))
	}
	if m.DeviceId != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.DeviceId))
	}
	if m.ImageCount != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.ImageCount))
	}
	if m.WarnType != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.WarnType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetSocolDiagnoseCouterCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SocolDiagnoseHoldWarnCounter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HoldId != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.HoldId))
	}
	if m.WarnType != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.WarnType))
	}
	if m.ImageTotal != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.ImageTotal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HoldId != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.HoldId))
	}
	if m.WarnType != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.WarnType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if len(m.CounterList) > 0 {
		for _, e := range m.CounterList {
			l = e.Size()
			n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
		}
	}
	if m.CounterTotal != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.CounterTotal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolTryLockCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LockKey)
	if l > 0 {
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	l = len(m.LockToken)
	if l > 0 {
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.LockTtl != 0 {
		n += 1 + sovMapgooPaasCapSocol(uint64(m.LockTtl))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSocolTryLockCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetSocolUnLockCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LockKey)
	if l > 0 {
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	l = len(m.LockToken)
	if l > 0 {
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetSocolUnLockCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateSocolRegisterStatCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeviceSocol != nil {
		l = m.DeviceSocol.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateSocolRegisterStatCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovMapgooPaasCapSocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMapgooPaasCapSocol(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMapgooPaasCapSocol(x uint64) (n int) {
	return sovMapgooPaasCapSocol(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SocolTaskCache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocolTaskCache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocolTaskCache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imei = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdSeq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CmdSeq == nil {
				m.CmdSeq = &SocolCmdSeq{}
			}
			if err := m.CmdSeq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CmdStatus == nil {
				m.CmdStatus = &SocolCmdStatus{}
			}
			if err := m.CmdStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskStatus", wireType)
			}
			m.TaskStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskStatus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredTime", wireType)
			}
			m.ExpiredTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadMsg == nil {
				m.UploadMsg = &SocolUploadMessage{}
			}
			if err := m.UploadMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadSummary == nil {
				m.UploadSummary = &SocolUploadSummary{}
			}
			if err := m.UploadSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSocolTaskCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSocolTaskCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSocolTaskCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaskCache == nil {
				m.TaskCache = &SocolTaskCache{}
			}
			if err := m.TaskCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageList = append(m.ImageList, &SocolUploadImage{})
			if err := m.ImageList[len(m.ImageList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSocolTaskCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSocolTaskCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSocolTaskCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolTaskCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolTaskCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolTaskCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdSeq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CmdSeq == nil {
				m.CmdSeq = &SocolCmdSeq{}
			}
			if err := m.CmdSeq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolTaskCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolTaskCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolTaskCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaskCache == nil {
				m.TaskCache = &SocolTaskCache{}
			}
			if err := m.TaskCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageList = append(m.ImageList, &SocolUploadImage{})
			if err := m.ImageList[len(m.ImageList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSocolTaskCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSocolTaskCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSocolTaskCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDelete", wireType)
			}
			m.IsDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsDelete |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdSeqList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmdSeqList = append(m.CmdSeqList, &SocolCmdSeq{})
			if err := m.CmdSeqList[len(m.CmdSeqList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageList = append(m.ImageList, &SocolUploadImage{})
			if err := m.ImageList[len(m.ImageList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CmdStatus == nil {
				m.CmdStatus = &SocolCmdStatus{}
			}
			if err := m.CmdStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadMsg == nil {
				m.UploadMsg = &SocolUploadMessage{}
			}
			if err := m.UploadMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadSummary == nil {
				m.UploadSummary = &SocolUploadSummary{}
			}
			if err := m.UploadSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredTime", wireType)
			}
			m.ExpiredTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSocolTaskCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSocolTaskCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSocolTaskCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolWillExpireTaskCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolWillExpireTaskCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolWillExpireTaskCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredTime", wireType)
			}
			m.ExpiredTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTime", wireType)
			}
			m.LockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolWillExpireTaskCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolWillExpireTaskCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolWillExpireTaskCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdSeqList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmdSeqList = append(m.CmdSeqList, &SocolCmdSeq{})
			if err := m.CmdSeqList[len(m.CmdSeqList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolDiagnoseCouterCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolDiagnoseCouterCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolDiagnoseCouterCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldId", wireType)
			}
			m.HoldId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			m.DeviceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolDiagnoseCouterCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolDiagnoseCouterCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolDiagnoseCouterCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageTotal", wireType)
			}
			m.ImageTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageTotal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldCounter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HoldCounter == nil {
				m.HoldCounter = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapgooPaasCapSocol
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapgooPaasCapSocol
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapgooPaasCapSocol
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMapgooPaasCapSocol
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HoldCounter[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCounter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceCounter == nil {
				m.DeviceCounter = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapgooPaasCapSocol
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapgooPaasCapSocol
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapgooPaasCapSocol
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMapgooPaasCapSocol
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DeviceCounter[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSocolDiagnoseCouterCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSocolDiagnoseCouterCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSocolDiagnoseCouterCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldId", wireType)
			}
			m.HoldId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			m.DeviceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageCount", wireType)
			}
			m.ImageCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarnType", wireType)
			}
			m.WarnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarnType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSocolDiagnoseCouterCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSocolDiagnoseCouterCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSocolDiagnoseCouterCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SocolDiagnoseHoldWarnCounter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocolDiagnoseHoldWarnCounter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocolDiagnoseHoldWarnCounter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldId", wireType)
			}
			m.HoldId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarnType", wireType)
			}
			m.WarnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarnType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageTotal", wireType)
			}
			m.ImageTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageTotal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolDiagnoseHoldWarnCouterCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolDiagnoseHoldWarnCouterCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldId", wireType)
			}
			m.HoldId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarnType", wireType)
			}
			m.WarnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarnType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolDiagnoseHoldWarnCouterCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolDiagnoseHoldWarnCouterCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolDiagnoseHoldWarnCouterCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterList = append(m.CounterList, &SocolDiagnoseHoldWarnCounter{})
			if err := m.CounterList[len(m.CounterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterTotal", wireType)
			}
			m.CounterTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CounterTotal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolTryLockCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolTryLockCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolTryLockCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTtl", wireType)
			}
			m.LockTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTtl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSocolTryLockCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSocolTryLockCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSocolTryLockCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSocolUnLockCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSocolUnLockCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSocolUnLockCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSocolUnLockCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSocolUnLockCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSocolUnLockCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSocolRegisterStatCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSocolRegisterStatCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSocolRegisterStatCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceSocol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceSocol == nil {
				m.DeviceSocol = &DeviceSocolInfo{}
			}
			if err := m.DeviceSocol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSocolRegisterStatCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSocolRegisterStatCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSocolRegisterStatCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseRespInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapgooPaasCapSocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapgooPaasCapSocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMapgooPaasCapSocol(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMapgooPaasCapSocol
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMapgooPaasCapSocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMapgooPaasCapSocol
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMapgooPaasCapSocol
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMapgooPaasCapSocol
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMapgooPaasCapSocol        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMapgooPaasCapSocol          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMapgooPaasCapSocol = fmt.Errorf("proto: unexpected end of group")
)
